inference_prompt
"You have the task of grading a programming assignment submission. The problem statement and resources provided by the instructor will be given between [INSTRUCTOR] and [/INSTRUCTOR] tags. The rubric that is supposed to be graded will be given between [RUBRIC] and [/RUBRIC] tags. The student submission will be between [SUBMISSION] and [/SUBMISSION] tags. You are supposed to come up with a score for the submission for the given rubric. I will give the instructor resources in second prompt then the rubric in the third prompt and the student submission in the fourth prompt. So in response to this first , second , third prompts just note the contents and output just the word NOTED and after the fourth prompt give only the score in between the tags [SCORE] and [/SCORE]."
"[INSTRUCTOR]
[Files]
[FILENAME]
moodle_description.txt
[/FILENAME]
[CONTENT]
In this assignment, we will implement a dynamic queue in two different ways. 

The problem statement is given in queue.h    Please read the problem statement carefully.

The harness for testing your code is given in test.cpp 

You need to write your solution (programs) in two files linearQueue.cpp and circularQueue.cpp and compile by running ""make testLinear"" or ""make testCircular"" as appropriate.

Do not worry about running gnuplot to visualize the running times now. We will send you separate instructions about that.  

# Submission stats
Participants	200
Submitted	193
[/CONTENT]
[/Files]
[/INSTRUCTOR]"
"[RUBRIC]
Is the Code well structured and commented
[POSSIBLESCORES]
[0,1,2]
[/POSSIBLESCORES]
[/RUBRIC]"
"[SUBMISSION]
[FILES]
[FILENAME]
linearQueue.cpp
[/FILENAME]
[CONTENT]
#include<iostream>
#include""queue.h""

using namespace std;

template <typename T> bool DynamicQueue<T>::isEmpty(){
	return (head==tail);
}	

template <typename T> bool DynamicQueue<T>::isFull(){
	return (tail==N && head==0);  
}

template <typename T> void DynamicQueue<T>::grow(){
	T* B=A;		//all the elemats of A were moved to the new array B
	A=new T[N+CONST_GROWTH]; //incremented the size of array A
	for(int i=head;i<tail;i++){
		A[i]=B[i];			//elements of B are again moved into A
	}
	N=nextSize();			//value of N is increased
}	

template <typename T> unsigned int DynamicQueue<T>::size(){
	return tail-head;		//this value returns the size of the array
}

template <typename T> void DynamicQueue<T>::QInsert(T x){
	if (tail == N){
		if(head==0){	//this is the case of full array
			grow();		//so the size of array is increased
		}
		else{
			for(int i=head;i<N;i++){	//Initial indexes were empty,so the head was shifted to 0 index and continued the process till tail
				A[i-head]=A[i];
			}
			tail=N-head;head=0;			//after shifting ,the new tail becomes N-head and head becomes 0
		}	
	}
	A[tail]=x;							//after the shifting,x is placed at the tail
	tail++;								//later the tail is incremented
}

template <typename T> bool DynamicQueue<T>::QDelete(T *x){
	if (head==tail){					//when array is empty,it returns false
		return false;
	}
	else{	
		*x=A[head];						
		head++;
		return true;
	}

}



[/CONTENT]
[FILENAME]
circularQueue.cpp
[/FILENAME]
[CONTENT]
#include<iostream>
#include""queue.h""

using namespace std;

template <typename T> unsigned int DynamicQueue<T>::size(){
	return ((tail-head+N)%N);			//this value returns the size of the array
}

template <typename T> bool DynamicQueue<T>::isEmpty(){
	return (head==tail);		
}	

template <typename T> bool DynamicQueue<T>::isFull(){
	if(size() == N-1)return true;		//if size is N-1 , it means the array is full
	else return false;
}	

template <typename T> void DynamicQueue<T>::grow(){
	T* B=A;							//all the elemats of A were moved to the new array B
	A=new T[N+CONST_GROWTH];		//incremented the size of array A

	if(head==0 && tail==N){
		for(int i=0;i<tail;i++){
			A[i]=B[i];				//elements of B are again moved into A
		}
	}
	N=nextSize();					//value of N is increased

	if(head==tail+1){				//this is the case when head>tail
		head+=CONST_GROWTH;
		for(int i=0;i<tail;i++){	
			A[i]=B[i];				//again similiarly elements of B are copied into A
		}
		for(int i=head;i<N;i++){	//this is case after head and N are increased
			A[i]=B[i-CONST_GROWTH];
		}
	}
}	

template <typename T> void DynamicQueue<T>::QInsert(T x){
	if(isFull()){
		grow();						//when array is full ,it needs to be growed and then the element should be added
		A[tail]=x;
		tail++;
	}
	else if(tail==N-1){				//when tail=N and queue is not full A[0] beacomes x and then tail is shifted to 1
		A[0]=x;
		tail=1;
	}
	else{
		A[tail]=x;					//this is the general case
		tail++;
	}
}

template <typename T> bool DynamicQueue<T>::QDelete(T *x){
	if (head==tail){				//when array is empty,it returns false
		return false;
	}
	else{							
		if(head==N-1){				//when head is N-1 then new head becomes 0 	
			*x=A[head];
			head=0;
		}
		else{
			*x=A[head];				//this is the usual case
			head++;
		}
		return true;
	}
}



[/CONTENT]
[/FILES]
[/SUBMISSION]"
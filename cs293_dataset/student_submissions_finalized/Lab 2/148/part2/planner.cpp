#include "planner.h"
#include "dictionary.h"
using namespace std;


void Station::addJourney(Journey *j){
        // Add a journey to the linked list of a particular station such that the ll remains sorted
        if (first == nullptr){
                first = j;
                return;
        }

        Journey *present = first;
        // Our train starts before the first one we had till now
        if(present->start_time- j->start_time > epsilon){
                j->next = present;
                first = j;
                return;
        }

        // Keep moving present until we reach a point where we can insert j such that the list remains sorted
        while(present->next != nullptr && j->start_time -  present->next->start_time > -epsilon){
                present = present->next;
        }

        // Insert j next to present

        Journey *temp = present->next;
        present->next = j;
        j->next = temp;
        return;
}
void add(string s1, string s2, float t1, float t2, Dictionary *d){
        // See if station 1 is there
        // If there just add a journey in its linked list
        // if not there create an entry for station 1, and add the present journey as its first element 
        Journey *j = new Journey(s1, s2, t1, t2);
        if(d->get(s1) == NULL){
                // Create a new station and put it in the dictionary
                Station * s = new Station(s1);
                s->first = j;
                d->put(s);
        }
        else{
                // Station is already in the dict, use the addJourney function to place the journey properly in the linked list
                d->get(s1)->value->addJourney(j);

                // TODO: Make this more efficient
        }
}


Journey * queryStation(string s, float t, Dictionary *d){
        // Returns the pointer to the journey such that all journey's in the list generated by doing journey->next on this, start from s and have starttime > t
        Entry *e = d->get(s);
        if(e==NULL){
                // Such a station does not exist
                return nullptr;
        }
        Station * stat = e->value;
        if (stat->first == nullptr){
                // Should never happen
                return nullptr;
        }

        Journey *j =stat->first;
        while(j->start_time - t<  -epsilon && j->next != nullptr){
                // Keep iterating till we reach the end, or reach a journey with start time >= t
                j = j->next;
        }
        if(j->start_time - t< -epsilon) {
                // All journeys start earlier
                return nullptr;
        }
        // If we reached the end without a suitable value return nullptr, handle this in the same way as not having a proper station

        return j;
}

void printAllSuccessiveJourneys(Journey * starting){
        // Takes the output from queryStation function and prints the values.
        if(starting == nullptr){
                std::cout << "ERROR"  << std::endl;
        }
        while(starting != nullptr){
                std::cout << starting->start_time << " " << starting->end  << endl;
                starting = starting->next;
        }
}

Journey * noStopJourney(string s1, float t, string s2, Dictionary *d){
        // Find the first direct journey after time t from s1 to s2
        // First we reach the point in the linked list associated with a station such that the trains after that have start time > t
        Journey * starting = queryStation(s1, t, d);
        while(starting!= nullptr && starting->end != s2){
                starting = starting->next;
        }
        return starting;
}

void queryJourney(string s1, float t, string s2, Dictionary *d){
        // Print the first journey from station s1 to station s2 starting after t. Can allow for atmost one joining station
        // First we reach the point in the linked list associated with a station such that the trains after that have start time > t


        Journey * starting = queryStation(s1, t, d);
        while(starting != nullptr){
                if(starting->end == s2){
                        std::cout << starting->start_time  << std::endl;
                        return;
                }
                Journey * noStop = noStopJourney(starting->end, starting->finish_time, s2, d);
                if (noStop!= nullptr){
                        std::cout << starting->start_time << " " << starting->end << " " << noStop->start_time  << endl;
                        return;
                }

                starting = starting->next;
        }
        cout << "ERROR"  << endl;

}


int main(){
        Dictionary *d = new Dictionary;
        while(true){
                string command;
                cin >> command;
                if(command=="EXIT"){
                        break;
                }
                else if(command == "ADD"){
                        string s1, s2;
                        float t1, t2;
                        cin >> s1 >> t1 >> s2 >> t2;
                        add(s1, s2, t1, t2, d);
                }
                else if(command == "QUERY_STATION"){
                        string s1;
                        float t;
                        cin >> s1 >> t;
                        printAllSuccessiveJourneys(queryStation(s1, t, d));
                }
                else if(command == "QUERY_JOURNEY"){
                        string s1, s2;
                        float t;
                        cin >> s1 >> t >> s2;
                        queryJourney(s1, t, s2, d);
                }
                else{
                        break;
                }
        }
        delete d;

}

#ifndef KMP_CPP
#define KMP_CPP

#ifndef PLANNER_H
#include "planner.h"
#endif

using namespace std;

string toLowerCase(string str) {

    int str_len = str.length();

    string final_str = "";

    for(int i=0; i<str_len; i++) {

        char character = str[i];

        if(character>=65 && character<=92) {

            final_str += (character+32);

        } else {

            final_str += character;

        }

    }

    return final_str;

}

int *Planner::computeHMatrixForKMP(string pattern) {

  string newpattern = toLowerCase(pattern);

  // int len = pattern.length();
  int len = newpattern.length();
  int *hMatrix = new int[len];

  // h(i) = 0
  hMatrix[0] = 0;

  int borderlength = 0;

  // Finding h values from index 1 to len-1
  for (int i = 1; i < len; i++) {

    // If first few letters are already matched
    // while (1 <= borderlength && pattern[borderlength] != pattern[i]){
    while (1 <= borderlength && newpattern[borderlength] != newpattern[i]){
      borderlength = hMatrix[borderlength-1];
    }
     
    // If pattern and first letter of pattern are the same
    if (newpattern[borderlength] == newpattern[i]){
        borderlength += 1;
    }

    hMatrix[i] = borderlength;

  }

  return hMatrix;
}

int Planner::KMPMatch(string text, int *hMatrix, string pattern) {

  string newpattern = toLowerCase(pattern);
  string newtext = toLowerCase(text);

  int lenText = text.length();
  // int lenPattern = pattern.length();
  int lenPattern = newpattern.length();

  // Tracking index of text
  int index = 0;

  if (lenText >= lenPattern) {
    // Tracking index of pattern
    int i = 0;

    // index + i == lenText means that pattern's last letter goes beyond text's last letter
    while ((index + i) < lenText) {      
      // if (text[index + i] == pattern[i]) {
      if (newtext[index + i] == newpattern[i]) {
        i++;
        
        // We found a match
        if (i == lenPattern) {
          return index;
        }

      } else {
        
        // If it is first letter of pattern and it is mismatch, we can just move index by 1
        if (i == 0) {
          index += 1;
        } else {

          // Shift using values generated by hMatrix
          index += i - hMatrix[i-1];
          i -= i - hMatrix[i-1];
        }
      }
    }

  }

  return -1;
}

#endif

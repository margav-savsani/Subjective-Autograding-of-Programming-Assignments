#ifndef QUICKSORT_CPP
#define QUICKSORT_CPP

#ifndef STD_HEADERS
#include "std_headers.h"
#endif

#ifndef PLANNER_H
#include "planner.h"
#endif

#ifndef DICTIONARY_H
#include "dictionary.h"
#endif

#ifndef CODES_H
#include "codes.h"
#endif
bool operator<(TrainInfoPerStation p1,TrainInfoPerStation p2 ){  //overloading the operator <
    for(int i=0;i<7;i++){
      if(p1.daysOfWeek[i]==1 && p2.daysOfWeek[i]==0) return true; //checking the day
      if(p1.daysOfWeek[i]==0 && p2.daysOfWeek[i]==1) return false;
    }
    if(p1.depTime<p2.depTime) return true; // checking the dept time if days are equal
    else if(p1.depTime==p2.depTime){
      if(p1.arrTime<p2.arrTime) return true; // checking the arrival time if dept time are equal
      else return false;
    }
    else return false;
}

int pivot(int a,int b){ //generating random pivot
  srand((unsigned)time(NULL)); 
  int r = (rand()%(b-a)) + a; //numbers generated by equal probabilitiy between a and b
  return r;
}
void exchange(TrainInfoPerStation*a,TrainInfoPerStation*b){ //exchanges two objects inside the addressses
  TrainInfoPerStation c(1,1,1,1);
  c=*a;                                   //addresses remains the same but objects in it get exchanged
  *a=*b;
  *b=c;
  return;

}

//returns  a pointer for object in linked list with given index
listOfObjects<TrainInfoPerStation*>* convertint(int a,listOfObjects<TrainInfoPerStation*>**s,int k){
  listOfObjects<TrainInfoPerStation*>*p;
  // if(a-(a/4)*4==0) p=s[a/4];        // getting the closest multiple of 4 and then going to index
  // else if(a-(a/4)*4==1) p=s[a/4]->next;
  // else if(a-(a/4)*4==2) p=s[a/4]->next->next;
  // else  p=s[a/4]->next->next->next;
  p=s[a/k];
  for(int i=0;i<a%k;i++){
    p=p->next;
  }


  return p; // returing pointer to object of linked list
}
void Planner::Quicksort(listOfObjects<TrainInfoPerStation *> *stnInfoList)
{return;
}
int partition(listOfObjects<TrainInfoPerStation *> *stnInfoList, int start, int end,listOfObjects<TrainInfoPerStation*>**s,int K){

TrainInfoPerStation*p;
listOfObjects<TrainInfoPerStation*>*st; // first element of linked list
int n=pivot(start,end); //pivot
p=convertint(n,s,K)->object;//pivot object 
TrainInfoPerStation replic_p=*p; // pivot class  
st=convertint(start,s,K);
listOfObjects<TrainInfoPerStation*>*f=st;
exchange(p,st->object); //exchnaging pivot class with first element


TrainInfoPerStation *k=f->object;
int c=0;               // counting no fo objects less than pivot
for(int i=1;i<end-start+1;i++){
  if( *(f->next->object) < *k )  c++;
  f=f->next;
}

int pivot=start+c;
listOfObjects<TrainInfoPerStation*>*piv;
piv=convertint(pivot,s,K);
exchange(st->object,piv->object); // echanging pivot and element at pivoth index
int i=start;int j=end;
while (i < pivot && j > pivot) {
 
        while (*(convertint(i,s,K)->object) < replic_p) {
            i++; // iterating until we get an element greater than pivot
        }
 
        while (replic_p < *(convertint(j,s,K)->object)) {
            j--;  //iterating until we get an element less than pivot
        }

 
        if (i < pivot && j > pivot) {
            exchange(convertint(i,s,K)->object, convertint(j,s,K)->object); // swapping
            i++;j--;
        }
}
return pivot;  // returning pivot
}

void Planner::QuicksortSimple(listOfObjects<TrainInfoPerStation *> *stnInfoList, int start, int end)
{   
    static int K=4;
    static int recursive=-1;
    static int length=0;
    recursive+=1;
    if(recursive==0){  // finding length of stinfo list
      listOfObjects<TrainInfoPerStation*>*t1=stnInfoList;
      length=0;
      while(t1!=NULL){
        length=length+1; //iterating through the linked list
        t1=t1->next;
      }
    }
    static listOfObjects<TrainInfoPerStation*>**s=new listOfObjects<TrainInfoPerStation*>*[((length-1)/K)+1];
    if(recursive==0){ // storing the list
      listOfObjects<TrainInfoPerStation*>*t2=stnInfoList;
      int i=0;int j=0;
      while(t2!=NULL){
        if(i%4==0){ // taking elements of indexs 0,4,8,....................
          s[j]=t2; //appending to list
          j+=1;
        }
        i=(i+1)%4;
        t2=t2->next;
      }
    }
    if(start<end){ // going to sort if it has >1 elements 
      int q = partition(stnInfoList,start,end,s,K); // partitioning
      QuicksortSimple(stnInfoList,start,q-1);   //quick sort for first partition                               
      QuicksortSimple(stnInfoList,q+1,end); // quixk sort for second partition
      
    }
    recursive-=1;
    return;
}







#endif

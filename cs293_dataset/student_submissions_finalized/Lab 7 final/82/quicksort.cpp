// Ckeck for both less than
// handle case when both left and right have same value
// Just two more (extreme) cases to handle: SEE_COMMENTS

#ifndef QUICKSORT_CPP
#define QUICKSORT_CPP

#ifndef STD_HEADERS
#include "std_headers.h"
#endif

#ifndef PLANNER_H
#include "planner.h"
#endif

#ifndef DICTIONARY_H
#include "dictionary.h"
#endif

#ifndef CODES_H
#include "codes.h"
#endif

#include <random>


// Pivot generation through has been achieved by usinga vector backUp which stores every kth pointer of the actual list 
listOfObjects<TrainInfoPerStation *> *genRandomPivot(int st, int en, int k, vector<listOfObjects<TrainInfoPerStation*>*> backUp)
{
	if (backUp[0] == nullptr)
		return nullptr;

	int n = en - st + 1;
	int rdn = rand()%n + st;
	int locL = rdn / k;	 // local location
	int locA = k * locL; // actual location
	// cout << k << ":" << rdn << ":" << locA<< endl;

	// moving forward from the pivot stored in backUp and moving next untill we reach the node that is generated according the random number generated.
	listOfObjects<TrainInfoPerStation *> *piv = backUp[locL];
	while (locA < rdn)
	{
		piv = piv->next;
		locA++;
	}

	return piv;
}

// print the listOfObjects list
void print(listOfObjects<TrainInfoPerStation *> *list, int st, int en)
{
	listOfObjects<TrainInfoPerStation*>* temp = list;
	int i=0;
	while(i < st){
		temp = temp->next;
		i++;
	}
	while(i <= en){
		cout << "{"<< temp->object->arrTime << " " << temp->object->depTime << " " << temp->object->journeyCode << "}";
		temp = temp->next;
		i++;
	}
	cout << endl;

}

// swap <TrainInfoPerStation*> objects from one listOfObjects pointer to another.
void swap(listOfObjects<TrainInfoPerStation *> *stn1, listOfObjects<TrainInfoPerStation *> *stn2)
{
	TrainInfoPerStation *temp = stn1->object;
	stn1->object = stn2->object;
	stn2->object = temp;
}


// calculate the length of the list from that point till end.
int lenStnList(listOfObjects<TrainInfoPerStation *> *stnInfoList)
{
	int len = 0;
	if (stnInfoList == nullptr)
		return len;
	listOfObjects<TrainInfoPerStation *> *temp = stnInfoList;
	while(temp != nullptr)
	{
		temp = temp->next;
		len++;
	}
	return len;
}


// check whether to swap or not according to the given day, arrTme and depTime constraints.
bool movePivot(listOfObjects<TrainInfoPerStation*>* comp, listOfObjects<TrainInfoPerStation*>* piv){
	bool a = false, b = false;
	for(int i=0; i<7; i++){
		if(comp->object->daysOfWeek[i]) {a = true;}
		if(piv->object->daysOfWeek[i]) {b = true;}
		if(a || b) break;
	}

	if(a && !b) return true;
	else if(!a && b) return false;
	else if(a && b){
		if(comp->object->arrTime == piv->object->arrTime){
			return comp->object->depTime < piv->object->depTime;
		}
		else{
			if(comp->object->arrTime == piv->object->arrTime){
				return comp->object->journeyCode < piv->object->journeyCode;
			}
			else{
				return comp->object->arrTime < piv->object->arrTime;
			}
		}
	}
}

// Partition the list using start and end index (using static variables in Quicksort AND using given parametres in QuicksortSimple )
// according to the random no. generated by the genRandomPivot() function
listOfObjects<TrainInfoPerStation *> *Planner::Partition(listOfObjects<TrainInfoPerStation *> *stnInfoList, int st, int en, int k, vector<listOfObjects<TrainInfoPerStation*>*> backUp)
{
	if(st >= en) return nullptr;

	listOfObjects<TrainInfoPerStation*> *pivot = genRandomPivot(st, en, k, backUp);

	int key = pivot->object->arrTime;
	listOfObjects<TrainInfoPerStation*> *left = stnInfoList, *right = stnInfoList, *newPiv = stnInfoList;
	
	int i = 0;
	for(i=0; i<st; i++){
		left = left->next;
		right = right->next;
		newPiv = newPiv->next;
	}
	while(i<en){
		right = right->next;
		i++;
	}
	swap(pivot, newPiv);
	listOfObjects<TrainInfoPerStation*>* trueNode = new listOfObjects<TrainInfoPerStation*>(newPiv->object);

	while(left != right){
		while(movePivot(left, trueNode) && left!= right){
			left = left->next;
		}
		while(!movePivot(right, trueNode) && left != right){
			right = right->prev;
		}
		if(left != right){
			// if(left->next == right && left->object->arrTime == right->object->arrTime){
			// 	right = right->prev; // handling the case when 2 elements only and they are same.
			// } // THIS WON'T HAPPEN HERE, ELSE WE WOULD HAVE TO HANDLE!
			
			swap(left, right);
			left = left->next;// moving the pointer ahead else it will lead to infinite recurrsion when the element becomes same.
			
		}

	}
	// ensuring the equal element is on the right part
	// and also handling one case when the left ends up at a pivot whose value is greater but its prev nodes has value smaller
	if(!(movePivot(left, trueNode)) && trueNode != left){
		// cout << left->object->arrTime << endl;
		delete trueNode;
		return left->prev;
	}
	delete trueNode;
	return left;

}

// Defining the required parametres statically to be defined only ones, and just using simple QuickSort algorithm
void Planner::Quicksort(listOfObjects<TrainInfoPerStation *> *stnInfoList)
{
	// A few static variable declarations
	static int K = 5;				// Parameter to be experimented with
	static int recursionLevel = -1; // This can be used to find out at which
									// level of the recursion you are in
	static vector<listOfObjects<TrainInfoPerStation *> *> backUp;
	static int start = 0;
	static int end = lenStnList(stnInfoList);
	// Increment recursion level on entering the function
	recursionLevel++;

	// If you need to set up additional storage (upto n/K TrainInfoPerStation
	// elements), it's ok to do it *once* using static variables/array.
	// Using the static recursionLevel, you can ensure that the storage
	// allocation is done only the first time Quicksort is called, and not
	// in every recursive call.
	//
	// Note that if you allocate space for upto n/K TrainInfoPerStation in
	// each recursive call, you will end up using much more than n/K space
	// overall.  So you MUST NOT allocate space in each recursive call.
	//
	// A variable/array defined using static is not created afresh in
	// each recursive call.  Instead, a single copy of it is maintained
	// across all recursions.

	if (recursionLevel == 0)
	{
		K = 5;
		start = 0;
		end = lenStnList(stnInfoList);
		backUp.clear();
		// Allocate additional space for upto n/K TrainInfoPerStation objects
		// if needed.
		// Do other things that you may want to do only at the beginning
		// as a pre-processing step.
		listOfObjects<TrainInfoPerStation *> *stnList = stnInfoList;
		for (int i = 0; stnList != nullptr; i++)
		{
			if (!(i % K))
			{
				backUp.push_back(stnList);
				stnList = stnList->next;
			}
			else{
				stnList = stnList->next;
			}
		}
	}

	if(start < end){
		int startPrev = start;
		int endPrev = end;
		listOfObjects<TrainInfoPerStation*> *pivot = Partition(stnInfoList, start, lenStnList(stnInfoList)-1, K, backUp);
		if(pivot == nullptr) {
			recursionLevel--;
			return;
		}
		end = lenStnList(stnInfoList)-lenStnList(pivot);
		Quicksort(stnInfoList);
		end = endPrev;
		start = lenStnList(stnInfoList)-lenStnList(pivot) + 1;
		Quicksort(stnInfoList);
		start = startPrev;
	}

	// Decrement recursion level before leaving the function
	recursionLevel--;
	return;
}

void Planner::QuicksortSimple(listOfObjects<TrainInfoPerStation *> *stnInfoList, int start, int end)
{
	// A few static variable declarations
	static int K = 4;				// Parameter to be experimented with
	static int recursionLevel = -1; // This can be used to find out at which
									// level of the recursion you are in
	static vector<listOfObjects<TrainInfoPerStation *> *> backUp;

	// Increment recursion level on entering the function
	recursionLevel++;

	// If you need to set up additional storage (upto n/K TrainInfoPerStation
	// elements), it's ok to do it *once* using static variables/array.
	// Using the static recursionLevel, you can ensure that the storage
	// allocation is done only the first time Quicksort is called, and not
	// in every recursive call.
	//
	// Note that if you allocate space for upto n/K TrainInfoPerStation in
	// each recursive call, you will end up using much more than n/K space
	// overall.  So you MUST NOT allocate space in each recursive call.
	//
	// A variable/array defined using static is not created afresh in
	// each recursive call.  Instead, a single copy of it is maintained
	// across all recursions.

	if (recursionLevel == 0)
	{
		K = 4;
		backUp.clear();
		// Allocate additional space for upto n/K TrainInfoPerStation objects
		// if needed.
		// Do other things that you may want to do only at the beginning
		// as a pre-processing step.
		listOfObjects<TrainInfoPerStation *> *stnList = stnInfoList;
		for (int i = 0; stnList != nullptr; i++)
		{
			if (!(i % K))
			{
				backUp.push_back(stnList);
				stnList = stnList->next;
			}
			else{
				stnList = stnList->next;
			}
		}
	}

	if(start < end){
		// print(stnInfoList, start, end);
		listOfObjects<TrainInfoPerStation*> *pivot = Partition(stnInfoList, start, lenStnList(stnInfoList)-1, K, backUp);
		if(pivot == nullptr) {
			recursionLevel--;
			return;
		}
		QuicksortSimple(stnInfoList, start, lenStnList(stnInfoList)-lenStnList(pivot));
		QuicksortSimple(stnInfoList, lenStnList(stnInfoList)-lenStnList(pivot) + 1, end);
	}
	// Put your code for the core of QuicksortSimple here

	// Decrement recursion level before leaving the function
	recursionLevel--;
	return;
}

#endif
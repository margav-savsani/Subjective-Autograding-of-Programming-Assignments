#ifndef STD_HEADERS
#include "std_headers.h"
#endif

#ifndef PLANNER_H
#include "planner.h"
#endif

#ifndef DICTIONARY_H
#include "dictionary.h"
#endif

#ifndef CODES_H
#include "codes.h"
#endif

#include <vector>

bool isGreaterThan(listOfObjects<TrainInfoPerStation *>* t1, listOfObjects<TrainInfoPerStation *>* t2){
  /**
   * This function compares two train info objects stored in the links in the station info list. It basically acts as
   * a comparator function for the nodes in the list of objects
   * Returns true if strictly greater than
   * if deptime is -1, it is considered greater than everything else
   * 
   */

  int i = 0;
  for(; i < 7; i++){
    if(t1->object->daysOfWeek[i]){
      break;
    }
  }
  int j = 0;
  for(; j < 7; j++){
    if(t2->object->daysOfWeek[j]){
      break;
    }
  }
  if(i > j){
    return true;
  }
  int dep1 = t1->object->depTime;
  if(dep1 == -1) dep1 = 100000;
  int dep2 = t2->object->depTime;
  if(dep2 == -1) dep2 = 100000;
  if(i == j && dep1 > dep2){    
    return true;    
  }
  return false;
}

bool isGeqTo(listOfObjects<TrainInfoPerStation *>* t1, listOfObjects<TrainInfoPerStation *>* t2){
  /**
   * The functionality is more or less the same as the above function with just the change that this is a
   * >= comparator
   * 
   */
  int i = 0;
  for(; i < 7; i++){
    if(t1->object->daysOfWeek[i]){
      break;
    }
  }
  int j = 0;
  for(; j < 7; j++){
    if(t2->object->daysOfWeek[j]){
      break;
    }
  }
  if(i > j){
    return true;
  }
  int dep1 = t1->object->depTime;
  if(dep1 == -1) dep1 = 100000;
  int dep2 = t2->object->depTime;
  if(dep2 == -1) dep2 = 100000;
  if(i == j && dep1 >= dep2){     
    return true;
  }
  return false;
}

listOfObjects<TrainInfoPerStation*>* findPivot(const vector<listOfObjects<TrainInfoPerStation *>*> &joints, int len, int k, int offset){
  /**
   * This returns a pivot randomly chosen within the start and end limits of the concerned links of the listOfObjects
   * The pivot is generated by storing the Kth element in the list into a vector while pre processing the array
   * and then these elements are used to aid in finding the random pivot by finding the corresponding joint through
   * random / k and then taking random % k steps. Note that random % k < k and hence we are finding the pivot in O(k)
   * time.
   * 
   */
  int index = offset + (rand() % len);
  cout << "pivot index " << index << endl;
  listOfObjects<TrainInfoPerStation *>* start = joints[index/k];
  for(int i = 0; i < index % k && start->next != nullptr; i++){    
    start = start->next;
  }
  
  return start;
}

 listOfObjects<TrainInfoPerStation *>* Partition(listOfObjects<TrainInfoPerStation *>* stnInfoList, listOfObjects<TrainInfoPerStation *>* pivot1, int len, int& partInd){
  /**
   * This function partitions the array based on the pivot, nothing radically different from the partition function
   * for an array, because even in the array, we almost partition it as if it is a linked list.
   * pivot is passed to this function as a pointer, there is also a partInd param passed by reference - this param is 
   * supposed to store the index of the partition
   * 
   */
  listOfObjects<TrainInfoPerStation*>* point1 = stnInfoList; //greater than pointer
  TrainInfoPerStation* pivotData = pivot1->object;
  listOfObjects<TrainInfoPerStation*>* point2 = stnInfoList; //less than pointer
  partInd = len-1;
  listOfObjects<TrainInfoPerStation*> cmp = *pivot1;
  listOfObjects<TrainInfoPerStation*>* pivot = &cmp;
  for(int i = 0; i < len-1; i++){
    point1 = point1->next;
  }
  //while(!(point2 == point1 || point1->next == point2 || point1 == nullptr || point2 == nullptr)){    
  while(!(point1->next == point2)){
    while(true){
      if(isGeqTo(pivot, point2)){
        point2 = point2->next;        
        if(point2 == nullptr){
          break;
        }
      }
      else{
        break;
      }
    }
    while(true){
      if(isGreaterThan(point1, pivot)){
        point1 = point1->prev;
        partInd--;
        if(point1 == nullptr){
          break;
        }
      }
      else{
        break;
      }
    }
    //if(!(point2 == point1 || point1->next == point2 || point1 == nullptr || point2 == nullptr)){
    if(!(point1->next == point2)){
      TrainInfoPerStation* temp = point1->object;
      point1->object = point2->object;
      point2->object = temp;
    }
  }
  // if(point1 == point1_cpy){
  //   partInd--;
  //   return point1->prev;
  // }
  if(partInd == len-1){
    //point1->object = pivotData;
    partInd--;
    TrainInfoPerStation* temp = pivot1->object;
    pivot1->object = point1->object;
    point1->object = temp;
    return point1->prev;
  }
  return point1;
}

void ActualQuicksort(listOfObjects<TrainInfoPerStation *> *stnInfoList, int len, int k, const vector<listOfObjects<TrainInfoPerStation *>*> &joints, int offset){
  /**
   * This is the function which puts all the functions together and performs the "actual" quicksort(the functiond below
   * are jsut used as wrapper functions). It takes offset as a param - offset is the start index of the subarray in the 
   * main array, len is the length of the part of the linked list to sort.
   * This function also takes a joints param by reference, which refers to the same joints vector used in findPivot()
   * function.
   * 
   */
  
  if(len <= 1){
    return;
  }
  //listOfObjects<TrainInfoPerStation*>* pivot = findPivot(joints, len, k, offset);  
  int partInd;
  listOfObjects<TrainInfoPerStation*>* part = Partition(stnInfoList, findPivot(joints, len, k, offset) , len, partInd);
  
  // if(part == nullptr){
  //   return;
  // }
  // if(part->next != nullptr){
  //    ActualQuicksort(part->next, len - partInd - 1, k, joints, partInd + offset + 1);
    
  // }
  if(stnInfoList != nullptr){
    
    ActualQuicksort(stnInfoList, partInd+1, k, joints, offset);
  }
  if(part->next != nullptr){
    ActualQuicksort(part->next, len - partInd - 1, k, joints, partInd + offset + 1);
    
  }
  
}

void Planner::QuicksortSimple(listOfObjects<TrainInfoPerStation *> *stnInfoList, int start, int end)

{
  /**
   * Used as a wrapper function for quicksort. Preprocessing is done in this function. The vector joints is 
   * created in this function and then passed by const reference to the further functions
   * 
   */
  // Put your code here.
  int temp = 0;
  int len = end-start+1;
  if(len == 1 || len == 0){
    return;
  }
  static int K = 2;
  listOfObjects<TrainInfoPerStation *>* trav = stnInfoList;
  vector<listOfObjects<TrainInfoPerStation *>*> joints(((len-1)/K) + 1); 
  while(trav != nullptr){    
    if(temp % K == 0){
      joints[temp/K] = trav;            
    }
    trav = trav->next;
    temp += 1;
  }
  ActualQuicksort(stnInfoList, len, K, joints, 0);  
}

void Planner::Quicksort(listOfObjects<TrainInfoPerStation *> *stnInfoList){
  /**
   * Used as a wrapper function for quicksort. Preprocessing is done in this function. The vector joints is 
   * created in this function and then passed by const reference to the further functions. Along with that, 
   * this also calculates the length, and finally all these params are passed into ActualQuicksort() function.
   * 
   */
  int len = 0;  
  static int K = 5;
  listOfObjects<TrainInfoPerStation *>* trav = stnInfoList;
  while(trav != nullptr){  
    trav = trav->next;
    len += 1;
  }
  if(len == 1 || len == 0){
    return;
  }
  
  vector<listOfObjects<TrainInfoPerStation *>*> joints(((len-1)/K) + 1); 
  int temp = 0;
  trav = stnInfoList;
  while(trav != nullptr){    
    if(temp % K == 0){
      joints[temp/K] = trav;            
    }
    trav = trav->next;
    temp += 1;
  }

  ActualQuicksort(stnInfoList, len, K, joints, 0);
}










#ifndef GRAPH_BST_CPP
#define GRAPH_BST_CPP

#ifndef STD_HEADERS_H
#include "std_headers.h"
#endif

#ifndef GRAPH_BST_H
#include "Graph.h"
#endif

#include<string>
// Add code as appropriate for your implementation


//BST insert function is implemeted here
void BST::insert(int n){
		if(root == nullptr){ // checking for an empty BST and doing the required things
			root = new TreeNode(n);
			return;
		}
		
		auto curr = root;
		while(true){ // traversing from the root to find the location where the new node is to be inserted according to the ordering 
			if(curr->object > n){ // when object placed at curr is greater just travel to the left of the curr and continue
				if(curr->left == nullptr){
					curr->left = new TreeNode(n);
					curr->left->parent = curr;
					return;
				}
				else{
					curr = curr->left;
					continue;
				}
			}
			
			if(curr->object < n){// when object placed at curr is smaller just travel to the right of the curr and continue
				if(curr->right == nullptr){
					curr->right = new TreeNode(n);
					curr->right->parent = curr;
					return;
				}
				else{
					curr = curr->right;
					continue;
				}
			}
			
			if(curr->object == n){// when object placed at curr is equal make the new node the predecessor of the curr node
				if(curr->left == nullptr){
					curr->left = new TreeNode(n);
					curr->left->parent = curr;
					return;
				}
				else{
					curr = curr->left;
					while(true){
						if(curr->right != nullptr){
							curr = curr->right;
						}
						curr->right = new TreeNode(n);
						curr->right->parent = curr;
						return;
					}
				}	
			}
			
		}
	}

//this function prints the BST in a nice manner
void BST::printBST(std::ostream &os,const std::string& prefix, bool isLeft=false){
	if( root != nullptr )
	{
	    os << prefix;

	    os << (isLeft ? "|--" : "|__" );

	    // print the value of the node
	    os << root->object << endl;
	    TreeNode *curr = root;
	    root = root->left;
	    // enter the next tree level - left and right branch
	    printBST(os, prefix + (isLeft ? "│   " : "    "), true);
	    root = curr->right;
	    printBST(os, prefix + (isLeft ? "│   " : "    "), false);
	    root = curr;
	}
}	

//this function is called only when the BST is to be destroyed or in a recursive call
void BST::recursiveDelete(TreeNode* curr)
{
	if(curr == nullptr)return;
	recursiveDelete(curr->right);
	recursiveDelete(curr->left);
	delete curr;
}

//insert function of the class List which is a template class.
template<typename T>
void List<T>::insert(T n)
{
	if(start == nullptr){ // when the list is empty
		start = new ListNode<T>(n);
		end = start;
		return;
	}	
	end->next = new ListNode<T>(n); // normal procedure to enter when the list is non empty
	end->next->prev = end;
	end = end->next;
}

//finding an object in a List object
template<typename T>
bool List<T>::find(T n){
	auto curr = start;
	while(curr!=nullptr){ // iterating through the list to find the object
		if(curr->node == n){
			return true;
		}
		else{
			curr = curr->next;
		}
	}
	return false;
}

//the main function call to to run modified DFS procedure on the graph
void Graph::modifiedDFS() {
	for(int i=0;i<numNodes;i++){ // iterates through all the vertices to ru modifiedDFS_visit function which is essential
		if(nodes[i].no_of_visits == 0){
			b = new BST();
			modifiedDFS_visit(i, -1); // call the modifiedDFS_visit procedure
			a->insert(b);
			b = nullptr;
		}	
	}
}

//this function prints the final results for diaply on the terminal 
void Graph::printResults() {
	for(int i=0;i<numNodes;i++){ // iterating throught the nodes to collect the required information generated by using modifiedDFS
		//cout << i+1 << " " << nodes[i].no_of_visits << endl;
		if(nodes[i].no_of_visits == 2){
			count--;
			twice++;	
		}
		if(nodes[i].no_of_visits == 1){
			ones++;
		}
		
		if(nodes[i].pred[0] == -1){
			connected_components++;
		}
		
	}
	cout << "No. of connected components: " << connected_components << endl;
	cout << "No. of nodes visited once: " << ones << endl;
	cout << "No. of nodes visited twice: " << twice << endl;
	cout << "No. of nodes that are present in a cycle: " << -count <<endl;
	cout << endl;
	//iterating the list of BST trees to print on the terminal 
	auto c = a->start;
	while(c!=nullptr){
		c->node->printBST(cout, "");
		cout << endl;
		c = c->next;
	}
}

void Graph::modifiedDFS_visit(int i, int parent){
	//cout << "VISITED " << i <<endl;
	b->insert(nodes[i].value);	//inserting the graph node value into the BST
	nodes[i].no_of_visits++; // incrementing the number of visits for that node
	auto visit_number = nodes[i].no_of_visits; //it represents the current number of visit we are on
	nodes[i].pred[visit_number - 1] = parent; // updating the pred in the graph node
	nodes[i].arr[visit_number - 1] = times;//updating the arr time in the graph node
	times++ ; //incrementing the time
	
	
	//cout << i <<endl;
	auto adjList = nodes[i].adjacent->start;
	while(adjList != nullptr){//iterating throught he adjList of the graph Node
		auto child_indx = adjList->node;
		
		if(nodes[i].pred[0] == child_indx || nodes[i].pred[1] == child_indx){} // this condition is imposed to stop the edge that has acted as 1 -> 2 to act as 2 -> 1
		
		else if(nodes[child_indx].no_of_visits == 0) // when the adjacent Node has no of visits 0 we have no risk and cna traverse freely
			modifiedDFS_visit(child_indx, i);
			
		else if(nodes[child_indx].no_of_visits >=2 ){} // stopping the no of visits of adjacent nodes to 2 
		
		else if(nodes[child_indx].no_of_visits == 1){ // when the number of visits are 1
			//this condition handles the case when the adjacent graph node has been traversed before from the same node as the current node
			if(nodes[i].pred[0] == child_indx || nodes[i].pred[1] == child_indx || nodes[child_indx].pred[0] == i){
				modifiedDFS_visit(child_indx, i);
			//	
				if(nodes[i].arr[0] < nodes[child_indx].arr[0] && nodes[child_indx].arr[0] < nodes[i].arr[1] && nodes[child_indx].dep[0] == -1){} // this condition is for cyclic nodes
				else if(nodes[child_indx].dep[0] - nodes[child_indx].arr[0] != nodes[child_indx].dep[1] - nodes[child_indx].arr[1]){}
				//this condition is too for cyclic nodes
				
				//this is when non cyclic nodes can occur
				else{
					count++;
					//cout << child_indx;
					//cout <<" ||Updated||"<<endl;
				}
				
			//	
			}
			else{
				modifiedDFS_visit(child_indx, i);
			}
		}
		adjList = adjList->next; // incrementing the adjList for iterating throught the adjacentList of the graoh node 
	}
	
	
	nodes[i].dep[visit_number - 1] = times;//updating the dep time in the graph node
	times++ ; // incrementing the time
}


#endif
